import giimport timegi.require_version('Gtk', '3.0')from gi.repository import Gtk,GObject,Gdk,Pango,GLibfrom wired_module import *#	Generated By WiredGTK for Python: by Rocky Nuarin, 2018 Phils#	#####################www.WireThemAll.com#####################import datetimefrom MySQLdb import OperationalErrorfrom copy import deepcopyclass Handler(usercontrol):	#WiredEvent def row_activated(self,value)	#add more events 	def __init__(self,*param):					initUI(self,param,w=400,h=400,title="WiredGTKV1.0",controlbox=True,startpos=(200,200),timeoutdestroy=-1)		self.GTKForms()		super().__init__(self.usercontrol)		self._text=''		self.sch=Scheduler(500)#500 ms		self.sch.Start()				self.obj=[]		self.clickISR=None			def DataSource(self,db,sql):		asc=self.getTable(sql,"select")		table=self.getTable(sql)		cols=self.getFields(db,table)        		rec=self.ExecuteQuerry(db,sql)		self.Display(cols,rec,False)					def Display(self,fields,listdata,_checkbox):		#for a in self.obj:			#self._table.remove(a)                 		c=self.LHorizontalFront.get_children()		for a in c:			self.LHorizontalFront.remove(a)		c=self.LVerticalFront.get_children()		for a in c:			self.LVerticalFront.remove(a)					self.obj=[]		self.row={}		self.col={}		self.rowsobject=[]		self.rowselected=[]		self.values=deepcopy(listdata)		self.fields=deepcopy(fields)  		self.PlaceGridRow(self.fields,0,True)						for i,rowdata in enumerate(self.values):			self.PlaceGridRow(rowdata,i+1) 				self.LVerticalFront.Width=100*len(self.fields)		self.LVerticalFront.Height=(len(self.values)+1)*31			self.LHorizontalFront.Width=100*len(self.fields)		self.vscrollbarwta1.Max=self.LVerticalFront.Height		self.hscrollbarwta1.Max=self.LHorizontalFront.Width	def PlaceGridRow(self,rowdata,i=0,header=False,width=100,height=30):		rowsobject=[]		for j,data in enumerate(rowdata):			caption = "Btn"+str(j)+str(i)			if header:				btn=Gtk.Entry()				btn.set_text(data)                                				btn.override_color(Gtk.StateType.NORMAL, Gdk.RGBA(0,0,1,1)) 				btn.modify_bg(Gtk.StateType.NORMAL, Gdk.Color(0,0,0))				a=0			else:				btn=Gtk.Entry()				btn.set_text(str(data))				a=0			btn.connect("button-press-event",self.click)			btn.set_size_request(width,height)     			if header:				self.LHorizontalFront.put(btn, (j)*width,(i)*height)				else:																										self.LVerticalFront.put(btn, (j)*width,(i-1)*height)			btn.set_visible(True)	#importtant				self.obj.append(btn)			self.row[btn]=i-1			self.col[btn]=j			rowsobject.append(btn)		self.rowsobject.append(rowsobject)	def click(self,*arg):		r,c= self.row[arg[0]],self.col[arg[0]]		if r==-1:return		#print r,c,self.values[r]		if self.clickISR!=None:			self.clickISR(self.values[r])#(r,c,self.values[r])		if self.caller!=None:			if 'row_activated' in self.wiredevents:					self.wiredevents['row_activated'](self.values[r])					ret=self.HighlightSelected(r+1)		pass	def Refresh(self):		self.Display(self.fields, self.values, None)			def HighlightSelected(self,row):		if row in self.rowselected:			for btn in self.rowsobject[row]:				btn.override_color(Gtk.StateType.NORMAL, Gdk.RGBA(0,0,0,1))                                         			self.rowselected.remove(row)        		else:			for btn in self.rowsobject[row]:				btn.override_color(Gtk.StateType.NORMAL, Gdk.RGBA(1,0,0,1))                 			self.rowselected.append(row)  	def DeleteSelectedValues(self):		if len(self.rowselected)!=0:			buf=[]			for i in range(0,len(self.values)):				if (i+1) in self.rowselected:					i=i				else:					buf.append(self.values[i])			self.values=buf			self.rowselected=[]			self.Refresh()                                 	def getSelectedValues(self):		ret=[]		for a in self.rowselected:			ret.append(self.values[a-1])		return ret	def getSelectedIndex(self):		ret=[]		for a in self.rowselected:			ret.append(a-1)		return ret	def AddItem(self,value):		self.values.append(value)		self.Refresh()                       	def AddItems(self,values):		for a in values:			self.values.append(a)		self.Refresh()                        		def reconnectMySql(self,db):		print ("DB has Run Away, pinging to reconnect")		db.ping(True)	def GetSingleRec(self,db,Table, Fields, Fieldsval,retvalfields):		curs=db.cursor()		#connectDBifRunAway()		long=int#PYTHON3		if type(Fieldsval)==int or type(Fieldsval)==float or type(Fieldsval)==long:			sql="select * from " + Table + " where " + Fields + " = " + Fieldsval 		else:#might be string or date or time    			sql="select * from " + Table + " where " + Fields + " = '" + str(Fieldsval) + "'"			#curs.execute (sql)		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		col=self.getFields(db,Table)		if len(results)==0:			return ""		for a in range(len(col)):			if col[a]==retvalfields:				return results[0][a]#first record only		return ""	def getFields(self,db,cols):		#connectDBifRunAway()		curs=db.cursor()		sql="SHOW COLUMNS FROM " + cols			for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		ret=[]		for a in results:			ret.append(a[0])		return ret	#ExecuteNonQuerry(db,"INSERT INTO data (Name, Date, Time) VALUES ('%s', '%s', '%s')" % ("Bago", Date(),Time()) )	#ExecuteNonQuerry(db,"UPDATE data SET Name='%s' WHERE Name='%s'" % ("Wala","raks"))			#ExecuteNonQuerry(db,"DELETE FROM data WHERE Name='%s'" % ("Bago"))		def ExecuteNonQuerry(self,db,sql):		curs=db.cursor()		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			db.commit()		return ""		def ExecuteQuerry(self,db,sql):		curs=db.cursor()		for a in range(2):			try:				'''				import multiprocessing				def query_with_timeout(dbc, timeout, query, *a, **k):					conn1, conn2 = multiprocessing.Pipe(False)					subproc = multiprocessing.Process(target=do_query,					args=(dbc, query, conn2)+a, kwargs=k)					subproc.start()					subproc.join(timeout)					if conn1.poll():						return conn1.recv()					subproc.terminate()					raise TimeoutError("Query %r ran for >%r" % (query, timeout))				def do_query(dbc, query, conn, *a, **k):					cu = dbc.cursor()					cu.execute(query, *a, **k)					curs=cu					return cu				query_with_timeout(db,10, sql,"","")				'''								curs.execute (sql)				#print("fin curs.execute " + sql)				break			except OperationalError as e:				#do what you want to do on the error				#print("reconnectMySql curs.execute " + sql)				self.reconnectMySql(db)			results = curs.fetchall()		return results	def getType(self,x):		long=int#PYTHON3		if type(x) is str:			return str		if type(x) is long:			return int		if x == None:			return str    		if type(x) is datetime.date:			return str #datetime.date		if type(x) is datetime.datetime:			return str #datetime.date    		if type(x) is datetime.timedelta:			return str #datetime.timedelta    		if type(x) is int:			return int		if type(x) is datetime.time:			return str #datetime.date        		if type(x) is datetime.timedelta:			return str #datetime.date    	def getTable(self,sql,after="from"):		flag=False		x=sql.split(" ")		for a in x:			if flag==True:				if a.lower() in ["\r","\t","\n","\t"]:					continue				else:					return a			if a.lower()==after:				flag=True	def activeXcreated(self,*args):		self.LHorizontalBack.Width=self.usercontrol.Width-20		self.LVerticalBack.Width=self.usercontrol.Width-20		self.vscrollbarwta1.Left=self.usercontrol.Width-20		self.vscrollbarwta1.Height=self.usercontrol.Height-20				self.LVerticalBack.Height=self.usercontrol.Height-self.LHorizontalBack.Height		self.hscrollbarwta1.Top=self.usercontrol.Height-20		self.hscrollbarwta1.Width=self.usercontrol.Width-8		self.vscrollbarwta1.Max=self.usercontrol.Height-20		self.hscrollbarwta1.Min=self.usercontrol.Width-20		self.Display(['Col1','Col2','Col3','Col4','Col5','Col6'],[['XXX','XXX','XXX','XXX','XXX']],False)		pass	def unload(self,*args):		destroy=True		if destroy==True:			GLib.source_remove(self.timeout_id)			self._window.hide()			del self._window			return False		else:			self.window.Visible=False			return True			def loop(self, user_data):		if self.form_load==False:			self.form_load=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 	def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})		def create(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		self.create("{'Enable': 'True', 'Top': '321', 'Value': '1', 'Picture': 'HScrollBarWTA.png', 'Events': '[change-value]', 'ForeColor': '(0,0,0,1)', 'Tag': 'Activex', 'BackColor': '(0, 0.17219081036574968, 0.1883747156203146, 0.5)', 'Name': 'hscrollbarwta1', 'Font': '', 'Height': '28', 'Left': '0', 'ParentsType': '', 'Text': 'hscrollbarwta1', 'Max': '100', 'Visible': 'True', 'Width': '426'}","HScrollBarWTA","usercontrol","[['change-value', 'self,value']]")		self.create("{'Enable': 'True', 'Top': '1', 'Value': '1', 'Picture': 'VScrollBarWTA.png', 'Events': '[change-value]', 'ForeColor': '(0,0,0,1)', 'Tag': 'Activex', 'BackColor': '(0, 0.050004155419702045, 0.9063815303698218, 0.5)', 'Name': 'vscrollbarwta1', 'Font': '', 'Height': '301', 'Left': '423', 'ParentsType': '', 'Text': 'vscrollbarwta1', 'Max': '100', 'Visible': 'True', 'Width': '30'}","VScrollBarWTA","usercontrol","[['change-value', 'self,value']]")		self.create("{'Enable': 'True', 'Top': '25', 'Picture': '', 'Events': '[]', 'ForeColor': '(0,0,0,1)', 'Tag': '', 'BackColor': '(0, 0.8560268326373737, 0.2818643092507779, 0.5)', 'Name': 'LVerticalBack', 'Font': '', 'Height': '293', 'Left': '0', 'ParentsType': '', 'Text': 'Layout1', 'Visible': 'True', 'Width': '427'}","Layout","usercontrol","[]")		self.create("{'Enable': 'True', 'Top': '0', 'Picture': '', 'Events': '[[, ]]', 'ForeColor': '(0,0,0,1)', 'Tag': '', 'BackColor': '(0, 0.6346244219293173, 0.6733716158531188, 0.5)', 'Name': 'LHorizontalBack', 'Font': '', 'Height': '45', 'Left': '0', 'ParentsType': '', 'Text': 'Layout2', 'Visible': 'True', 'Width': '426'}","Layout","usercontrol","[]")		self.create("{'Enable': 'True', 'Top': '5', 'Picture': '', 'Events': '[]', 'ForeColor': '(0,0,0,1)', 'Tag': '', 'BackColor': '(0, 0.154049067380161, 0.18193621479977118, 0.5)', 'Name': 'LVerticalFront', 'Font': '', 'Height': '236', 'Left': '1', 'ParentsType': 'Layout', 'Text': 'Layout3', 'Visible': 'True', 'Width': '300'}","Layout","LVerticalBack","[]")		self.create("{'Enable': 'False', 'Top': '3', 'Picture': '', 'Events': '[]', 'ForeColor': '(0,0,0,1)', 'Tag': '', 'BackColor': '(0, 0.738436974529033, 0.6747485880494434, 0.5)', 'Name': 'LHorizontalFront', 'Font': '', 'Height': '25', 'Left': '0', 'ParentsType': 'Layout', 'Text': 'Layout4', 'Visible': 'True', 'Width': '422'}","Layout","LHorizontalBack","[]")	def Widget(self):		if self._usercontrol in self._mainlayout.get_children():			self._mainlayout.remove(self._usercontrol)		return self._usercontrol	def Hide(self):		self._window.hide()	def Show(self,modal=False):		self._window.set_modal(modal)		self._window.show()		Gtk.main()	def vscrollbarwta1_change_value(self,value):		if float(value)<5:value=-5	#avoid first row not responding to click		self.LVerticalFront.Top=-float(value)		pass	def hscrollbarwta1_change_value(self,value):		self.LVerticalFront.Left=-float(value)		self.LHorizontalFront.Left=-float(value)		passif __name__ == "__main__":	_m = Handler()	_m._window.show()	Gtk.main()