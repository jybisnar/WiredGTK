import giimport timegi.require_version('Gtk', '3.0')from gi.repository import Gtk,GObject,Gdk,Pango,GLibfrom wta_module import *#	Generated By WiredGTK for Python: by Rocky Nuarin, 2018 Phils#	#####################www.WireThemAll.com######################import pdb; pdb.set_trace();from PIL import Imagefrom PIL import ImageDrawfrom pycoral.adapters import commonfrom pycoral.adapters import detectfrom pycoral.utils.dataset import read_label_filefrom pycoral.utils.edgetpu import make_interpreterimport cv2import numpy as npclass Handler(usercontrol):	#WiredProperty 'ModelFolder': 'mymodel'	#WiredProperty 'Frozen_Inference': 'ssd_mobilenet_v1_coco_quant_postprocess_edgetpu.tflite'	#WiredProperty 'LabelMap': 'coco_labels.txt'	#WiredProperty 'Threshold': '0.65'	def __init__(self,*param):					initUI(self,param,w=400,h=400,title="WiredGTKV1.0",controlbox=True,startpos=(200,200),timeoutdestroy=-1)		self.GTKForms()		super().__init__(self.usercontrol)		self.sch=Scheduler(500)#500 ms		self.sch.Start()		self._text=''						self._ModelFolder=""		self._Frozen_Inference=""		self._LabelMap=""		self._Threshold=""	@property	def Threshold(self):		return self._Threshold	@Threshold.setter		def Threshold(self,value):		self._Threshold=float(value)	@property	def LabelMap(self):		return self._LabelMap	@LabelMap.setter		def LabelMap(self,value):		self._LabelMap=value	@property	def Frozen_Inference(self):		return self._Frozen_Inference	@Frozen_Inference.setter		def Frozen_Inference(self,value):		self._Frozen_Inference=value	@property	def ModelFolder(self):		return self._ModelFolder	@ModelFolder.setter		def ModelFolder(self,value):		self._ModelFolder=value		def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})	def load_model(self,model_name):		fname=model_name+"/"+self.Frozen_Inference		if FileExist(fname)==False:			print(fname + " Not Found")			return None		fname=model_name+"/"+self.LabelMap		if FileExist(fname)==False:			print(fname + " Not Found")			return None		PATH_TO_LABELS = model_name+'/'+self.LabelMap		self.labels = read_label_file(PATH_TO_LABELS)		interpreter = make_interpreter(model_name+"/"+self.Frozen_Inference)		interpreter.allocate_tensors()		return interpreter		def draw_objects(self,draw, objs, labels):		"""Draws the bounding box and label for each object."""		for obj in objs:			bbox = obj.bbox			draw.rectangle([(bbox.xmin, bbox.ymin), (bbox.xmax, bbox.ymax)],						outline='red')			draw.text((bbox.xmin + 10, bbox.ymin + 10),					'%s\n%.2f' % (labels.get(obj.id, obj.id), obj.score),					fill='red')	def Detect(self,image_np):		#Running the tensorflow session				image=Image.fromarray(image_np)		_, scale = common.set_resized_input(			self.interpreter, image.size, lambda size: image.resize(size, Image.ANTIALIAS))							self.interpreter.invoke()		objs = detect.get_objects(self.interpreter, self._Threshold, scale)				'''			print(labels.get(obj.id, obj.id))		print('  id:    ', obj.id)		print('  score: ', obj.score)		print('  bbox:  ', obj.bbox)		'''		self.draw_objects(ImageDraw.Draw(image), objs, self.labels)		image_np=np.array(image)		return cv2.resize(image_np,(640,480)),objs	def activeXcreated(self,*args):		MODEL_NAME = self.ModelFolder		self.interpreter = self.load_model(MODEL_NAME.replace("\\","/"))		pass	def unload(self,*args):		destroy=True		if destroy==True:			GLib.source_remove(self.timeout_id)			self._window.hide()			del self._window			#ExitApplication() #activate this if u want to destroy this window			return False		else:			self.window.Visible=False			return True			def loop(self, user_data):		if self.form_load==False:			self.form_load=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 		def create(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		pass	def Widget(self):		if self._usercontrol in self._mainlayout.get_children():			self._mainlayout.remove(self._usercontrol)		return self._usercontrol	def Hide(self):		self._window.hide()	def Show(self,modal=False,x=None,y=None):		if x!=None:			self._window.move(x,y)		if modal and self.caller!=None:			self._window.set_transient_for(self.caller._window)		self._window.set_modal(modal)		self._window.show()		Gtk.main()		return ""#put ur return value here upon closing this formif __name__ == "__main__":	_m = Handler()	_m._window.show()	Gtk.main()