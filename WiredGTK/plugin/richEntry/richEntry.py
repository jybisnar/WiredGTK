import giimport timeimport MySQLdbgi.require_version('Gtk', '3.0')from gi.repository import Gtk,GObject,Gdk,Pango,GLibfrom wta_module import *#	Generated By WiredGTK for Python: by Rocky Nuarin, 2018 Phils#	#####################www.WireThemAll.com#####################class RichText:	NUMBER=1	FLOAT=2	STRING=3	NONE=4	def __init__(self,_self,TextView,flag,maxsize):		self.t=TextView		self.max=maxsize		self._self=_self		self.flag=flag		if flag!=self.STRING:			self.t.Text=0		else:			self.t.Text=""		self.t.connect("key-press-event",self.key_press_event)		self.t.connect("key-release-event",self.key_release_event)		self.t.connect("changed",self.changed)		self.t.connect("enter_notify_event",self.enter_notify_event)		self.t.connect("leave_notify_event",self.leave_notify_event)					def enter_notify_event(self,*arg):		if self._self.caller!=None and 'enter_notify_event' in self._self.wiredevents:self._self.wiredevents['enter_notify_event'](arg[0],arg[1])	def leave_notify_event(self,*arg):		if self._self.caller!=None and 'leave_notify_event' in self._self.wiredevents:self._self.wiredevents['leave_notify_event'](arg[0],arg[1])	def changed(self,*arg):		self._self._text=forms(arg[0]).Text		if self._self.caller!=None and 'changed' in self._self.wiredevents:self._self.wiredevents['changed'](arg[0])	def key_release_event(self,*arg):		key=arg[1].get_keyval()[1]		if key in[65363,65361,65288,65535]:			if self._self.caller!=None and 'key_press_event' in self._self.wiredevents:self._self.wiredevents['key_press_event'](arg[0],arg[1])			return False		key=chr(key)		if key in ['1','2','3','4','5','6','7','8','9','0','.']:			if key==".":				if self.flag==self.NUMBER or self.flag==self.FLOAT:								if self.t.Text!='' and float(self.t.Text)>self.max:						self.t.Text=self.max					pass			if self._self.caller!=None and 'key_release_event' in self._self.wiredevents:self._self.wiredevents['key_release_event'](arg[0],arg[1])	def key_press_event(self,*arg):				#print(arg[1].get_keyval())		key=arg[1].get_keyval()[1]		if key in[65363,65361,65288,65535]:			if self._self.caller!=None and 'key_press_event' in self._self.wiredevents:self._self.wiredevents['key_press_event'](arg[0],arg[1])			return False		key=chr(key)		if self.flag==self.NONE:			return False		if self.flag!=self.STRING:			if key in ['1','2','3','4','5','6','7','8','9','0','.']:				if key==".":					if self.flag!=self.FLOAT:						return True					if self.flag==self.FLOAT and self.t.Text.find(".")!=-1 :						return True				if self._self.caller!=None and 'key_press_event' in self._self.wiredevents:self._self.wiredevents['key_press_event'](arg[0],arg[1])				return False			else:				return True		else:#STRING			if (key.isalpha() or key==' ' or key=='-') and len(self.t.Text)<self.max:				if self._self.caller!=None and 'key_press_event' in self._self.wiredevents:self._self.wiredevents['key_press_event'](arg[0],arg[1])				return False			else:				return True		passclass Handler(usercontrol):	#WiredProperty 'Input': 'FLOAT','list':["FLOAT","INTEGER","STRING","NONE"]	#WiredProperty 'MaxChar': '99'	#WiredProperty 'PasswordChar': ''	#WiredProperty 'Alignment': 'LEFT','list':["LEFT","CENTER","RIGHT"]	#WiredEvent def key_press_event(self,*arg)	#WiredEvent def key_release_event(self,*arg)	#WiredEvent def enter_notify_event(self,*arg)	#WiredEvent def leave_notify_event(self,*arg)	#WiredEvent def changed(self,e)	#WiredProperty 'dbTable': ''	#WiredProperty 'dbFields': ''	#WiredProperty 'dbWhere': ''	#WiredProperty 'dbType': 'mysql'	def __init__(self,*param):					initUI(self,param,w=400,h=400,title="WiredGTKV1.0",controlbox=True,startpos=(200,200),timeoutdestroy=-1)		self.GTKForms()				super().__init__(self.usercontrol)		self.Font=20		self.sch=Scheduler(500)#500 ms		self.sch.Start()		self._text=''		self._usercontrolproperty=''		self._Input=""		self._MaxSize=99		self._PasswordChar=""		self._alignment=""		self._dbTable=""		self._dbFields=""		self._dbWhere=""		self._dbConnect=""		self._dbtype="mysql"	@property#override usercontrol Text property	def Text(self):		if self.TextView1.Visible==True:			return self._text		else:			return self.ComboBoxText1.List	@Text.setter	def Text(self,value):		self._text=value 		self.TextView1.Text=value		self.TextView1.Visible=True		self.ComboBoxText1.Visible=False	@property	def dbType(self):		return self._dbtype	@dbType.setter		def dbType(self,value):		self._dbtype=value	def getFields(self,db,cols):		#connectDBifRunAway()		curs=db.cursor()		if self._dbtype=="mysql":			sql="SHOW COLUMNS FROM " + cols			index=0		if self._dbtype=="sqllite":			sql="PRAGMA table_info("+cols+")"			index=1		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		ret=[]		for a in results:			ret.append(a[index])		return ret	def reconnectMySql(self,db):		print ("DB has Run Away, pinging to reconnect")		db.ping(True)	def RetribValue(self,db):#Table, Fields, Fieldsval,retvalfields):		curs=db.cursor()		#connectDBifRunAway()		long=int#PYTHON3		if self.dbWhere!="":			sql="select * from " + self.dbTable + " where " +self.dbWhere		else:			sql="select * from " + self.dbTable 				#curs.execute (sql)		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		col=self.getFields(db,self.dbTable)		if len(results)==0:			return ""				if len(results)>1:			lst=[]			for b in results:				for a in range(len(col)):					if col[a]==self.dbFields:							lst.append(b[a])			self.ComboBoxText1.List=lst			self.TextView1.Visible=False			self.ComboBoxText1.Visible=True			return lst		self.ComboBoxText1.ListIndex=0		self._text=self.ComboBoxText1.Text		self.TextView1.Visible=True		self.ComboBoxText1.Visible=False		for a in range(len(col)):			if col[a]==self.dbFields:				self.TextView1.Text=results[0][a]				self._text=self.TextView1.Text				return results[0][a]#first record only				return ""	@property	def dbWhere(self):		return self._dbWhere	@dbWhere.setter		def dbWhere(self,value):		self._dbWhere=value	@property	def dbFields(self):		return self._dbFields	@dbFields.setter		def dbFields(self,value):		self._dbFields=value	@property	def dbTable(self):		return self._dbTable	@dbTable.setter		def dbTable(self,value):		self._dbTable=value		@property	def Alignment(self):		return self._alignment	@Alignment.setter		def Alignment(self,value):		self._alignment=value	@property	def PasswordChar(self):		return self._PasswordChar	@PasswordChar.setter		def PasswordChar(self,value):		self._PasswordChar=value	@property	def MaxChar(self):		return self._MaxSize	@MaxChar.setter		def MaxChar(self,value):		self._MaxSize=value	@property	def Input(self):		return self._Input	@Input.setter		def Input(self,value):		if value=="INTEGER":			value=1		if value=="FLOAT":			value=2		if value=="STRING":			value=3		if value=="NONE":			value=4		self.rich=RichText(self,self.TextView1,value,int(self._MaxSize))		self._Input=value		def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})	def activeXcreated(self,*args):		self.TextView1.Width=self.usercontrol.Width		self.TextView1.Height=self.usercontrol.Height		self.TextView1.Font=self._font		self.TextView1.Alignment=self._alignment		self.TextView1.override_background_color(Gtk.StateFlags.SELECTED,Gdk.RGBA(0.8,0.8,1,1))			value=self._backcolor		self.TextView1.override_background_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(value[0],value[1],value[2],value[3])) 		self.TextView1.ForeColor=self._forecolor		if self._PasswordChar!="":			self.TextView1.set_visibility(False) 					pass	def unload(self,*args):		destroy=True		if destroy==True:			GLib.source_remove(self.timeout_id)			self._window.hide()			del self._window			#ExitApplication() #activate this if u want to destroy this window			return False		else:			self.window.Visible=False			return True			def loop(self, user_data):		if self.form_load==False:			self.form_load=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 		def create(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		self.TextView1=forms		self.create("{'Help': '', 'Height': '30', 'Visible': 'True', 'Alignment': '', 'Var': '', 'Name': 'TextView1', 'Picture': '', 'Text': 'Entry1', 'BackColor': '(1,1,1,1)', 'Width': '170', 'ParentsType': '', 'Enable': 'True', 'Top': '0', 'ForeColor': '(0,0,0,1)', 'Tag': '', 'Left': '0', 'Font': '', 'Events': '[[, ]]'}","Entry","usercontrol","[]")		self.ComboBoxText1=forms		self.create("{'Help': '', 'Height': '30', 'Visible': 'False', 'Var': '', 'Name': 'ComboBoxText1', 'Picture': '', 'Text': 'ComboBoxText1', 'BackColor': '(1,1,1,1)', 'Width': '175', 'ParentsType': '', 'Enable': 'True', 'Top': '0', 'ForeColor': '(0,0,0,1)', 'Tag': '', 'Left': '0', 'Font': '', 'Events': '[change-value, changed]'}","ComboBoxText","usercontrol","[['change-value', 'self,*args'], ['changed', 'self,e']]")	def Widget(self):		if self._usercontrol in self._mainlayout.get_children():			self._mainlayout.remove(self._usercontrol)		return self._usercontrol	def Hide(self):		self._window.hide()	def Show(self,modal=False,x=None,y=None):		if x!=None:			self._window.move(x,y)		if modal and self.caller!=None:			self._window.set_transient_for(self.caller._window)		self._window.set_modal(modal)		self._window.show()		Gtk.main()		return ""#put ur return value here upon closing this form	def ComboBoxText1_change_value(self,*args):		self._text=self.ComboBoxText1.Text		pass	def ComboBoxText1_changed(self,e):		self._text=self.ComboBoxText1.Text		passif __name__ == "__main__":	_m = Handler()	_m._window.show()	Gtk.main()