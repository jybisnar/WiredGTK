import giimport timegi.require_version('Gtk', '3.0')from gi.repository import Gtk,GObject,Gdk,Pango,GLibfrom wta_module import *import datetimefrom MySQLdb import OperationalError#	Generated By WiredGTK for Python: by Rocky Nuarin, 2018 Phils#	#####################www.WireThemAll.com#####################class Handler(usercontrol):	#WiredEvent def dblclick(self,model,row,col)	#add more events 	#WiredProperty 'FontStyle': 'Times New Roman'	#WiredProperty 'FontSize': '14'	#WiredProperty 'SELECT': '#FFAAAA"	#WiredProperty 'UNSELECT': '#FFFFFF"	#WiredProperty 'AlternateColor': 'False'	#WiredProperty 'dbtype': 'sqllite','list':["sqllite","mysql"]	def __init__(self,*param):					initUI(self,param,w=400,h=400,title="WiredGTKV1.0",controlbox=True,startpos=(200,200),timeoutdestroy=-1)		self.GTKForms()		super(usercontrol).__init__(usercontrol)		self.sch=Scheduler(500)#500 ms		self.sch.Start()		self._text=''		self._usercontrolproperty=''		self.fontstyle=''		self.fontsize=''		self.editablelst=[]		self.model=None		self.select='#FFAAAA'		self.unselect='#FFFFFF'		self.sig1=None		self.alternatecolor=False		#self.activeXcreated()		#self.Editable(True)		self._dbtype=""	@property	def dbtype(self):		return self._dbtype	@dbtype.setter		def dbtype(self,value):		self._dbtype=value	@property		def FontSize(self):		return self.fontsize	@FontSize.setter		def FontSize(self,value):		self.fontsize=value		self.TreeView1.Font=self.fontstyle+','+self.fontsize	@property		def SELECT(self):		return self.select	@SELECT.setter		def SELECT(self,value):		self.select=value	@property		def AlternateColor(self):		return self.alternatecolor	@AlternateColor.setter		def AlternateColor(self,value):		self.alternatecolor=value			@property		def UNSELECT(self):		return self.unselect	@UNSELECT.setter		def UNSELECT(self,value):		self.unselect=value	@property		def FontStyle(self):		return self.fontstyle	@FontStyle.setter		def FontStyle(self,value):		self.fontstyle=value		self.TreeView1.Font=self.fontstyle+','+self.fontsize	def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})		def TreeViewFilterWindow(self,_fields,_listdata):		#Creating the ListStore model		_types=[]		if len(_listdata):			for types in _listdata[0]:				_types.append(self.getType(types))			_types.append(str)#acommodate color				software_liststore = Gtk.ListStore(*_types)#(str, int, str)						else:			software_liststore = Gtk.ListStore()		self.model=software_liststore			colors=['#eeaaee','#eeeeee']			for i,software_ref in enumerate(_listdata):			list_software_ref=list(software_ref)			for b in range(len(list_software_ref)):								if type(list_software_ref[b]) in [datetime.datetime,datetime.date,datetime.timedelta,datetime.time]:						list_software_ref[b]=str(list_software_ref[b])				if self.AlternateColor=='True':				_color=colors[i&1]				else:				_color='#ffffff'			software_liststore.append(list_software_ref+[_color])		current_filter_language = None		language_filter = software_liststore.filter_new()		#setting the filter function, note that we're not using the		#language_filter.set_visible_func(language_filter_func)		#creating the treeview, making it use the filter as a model, and adding the columns		#self.treeview = Gtk.TreeView.new_with_model(self.language_filter)		self.TreeView1.set_model(language_filter)			#remove previos column raks		x=self.TreeView1.get_columns()		for a in x:			self.TreeView1.remove_column(a)    		#remove previos column raks		colorindex=len(_fields)		self.editablelst=[]		self.column=_fields		for i, column_title in enumerate(_fields):			renderer = Gtk.CellRendererText()			self.editablelst.append(renderer)			column = Gtk.TreeViewColumn(column_title, renderer, text=i,background=colorindex)			column.set_resizable(True)			self.TreeView1.append_column(column)		def language_filter_func(self, model, iter, data):			"""Tests if the language in the row is the one in the filter"""			if self.current_filter_language is None or self.current_filter_language == "None":				return True			else:				return model[iter][2] == self.current_filter_language		def on_selection_button_clicked(self, widget):			"""Called on any of the button clicks"""			#we set the current language filter to the button's label			self.current_filter_language = widget.get_label()			print("%s language selected!" % self.current_filter_language)			#we update the filter, which updates in turn the view			self.language_filter.refilter()					self.TreeView1.set_hover_selection(True)		if self.sig1==None:			self.sig1=self.TreeView1.connect('row-activated',self.row_activated) 	def row_activated(self,*r):		def getcollumn():			for i,a in enumerate(self.column):				if a==r[2].get_title():					return i		#xx=r[0].get_selection()		#(model, iter) = xx.get_selected()		#print()		if self.caller!=None:			if 'dblclick' in self.wiredevents:				model=r[0].get_model()				col=getcollumn()				row=r[1].get_indices()				row=row[0]				self.wiredevents['dblclick'](model,row,col)		def selectionState(self,row):		if self.model[row][-1]==self.SELECT:			return True		else:			return False	def selectthis(self,row,flag):		if flag==True:			self.model[row][-1]=self.SELECT		else:			self.model[row][-1]=self.UNSELECT			def Editable(self,allow=False):		for a in self.editablelst:			a.set_property("editable", allow)	def activeXcreated(self,*args):		self.TreeViewFilterWindow(["Column 1","Column 2","Column 3"], [['x','x','x'],['x','x','x'],['x','x','x']])		self.ScrolledWindow1.Width= self.usercontrol.Width		self.ScrolledWindow1.Height= self.usercontrol.Height		pass	def get_ListStore(self):#		return self.model			def unload(self,*args):		destroy=True		if destroy==True:			GLib.source_remove(self.timeout_id)			self._window.hide()			del self._window			#ExitApplication() #activate this if u want to destroy this window			return False		else:			self.window.Visible=False			return True			def loop(self, user_data):		if self.form_load==False:			self.form_load=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 		def create(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		self.create("{'Text': 'ScrolledWindow1', 'Var': '', 'ParentsType': '', 'Height': '418', 'Picture': '', 'Events': '[[, ]]', 'ForeColor': '(0,0,0,1)', 'Visible': 'True', 'Help': '', 'Tag': '', 'BackColor': '(0, 0.018319038209809735, 0.6514057800512267, 0.5)', 'Font': '', 'Enable': 'True', 'Left': '0', 'Width': '444', 'Top': '0', 'Name': 'ScrolledWindow1'}","ScrolledWindow","usercontrol","[]")		self.create("{'Text': 'TreeView1', 'Var': '', 'ParentsType': 'ScrolledWindow', 'Height': '140', 'Picture': '', 'Events': '[[, ]]', 'ForeColor': '(0,0,0,1)', 'Visible': 'True', 'Help': '', 'Tag': '', 'BackColor': '(1,1,1,1)', 'Font': '', 'Enable': 'True', 'Left': '59', 'Width': '180', 'Top': '60', 'Name': 'TreeView1'}","TreeView","ScrolledWindow1","[]")	def Widget(self):		if self._usercontrol in self._mainlayout.get_children():			self._mainlayout.remove(self._usercontrol)		return self._usercontrol	def Hide(self):		self._window.hide()	def Show(self,modal=False,x=None,y=None):		if x!=None:			self._window.move(x,y)		self._window.set_modal(modal)		self._window.show()		Gtk.main()		return ""#put ur return value here upon closing this form	###MySQL routine	def DataSource(self,db,sql):		asc=self.getTable(sql,"select")		table=self.getTable(sql)		cols=self.getFields(db,table)        		rec=self.ExecuteQuerry(db,sql)		self.TreeViewFilterWindow(cols, rec)		#self.Display(cols,rec,False)			def reconnectMySql(self,db):		print ("DB has Run Away, pinging to reconnect")		db.ping(True)	def GetSingleRec(self,db,Table, Fields, Fieldsval,retvalfields):		curs=db.cursor()		#connectDBifRunAway()		long=int#PYTHON3		if type(Fieldsval)==int or type(Fieldsval)==float or type(Fieldsval)==long:			sql="select * from " + Table + " where " + Fields + " = " + Fieldsval 		else:#might be string or date or time    			sql="select * from " + Table + " where " + Fields + " = '" + str(Fieldsval) + "'"			#curs.execute (sql)		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		col=self.getFields(db,Table)		if len(results)==0:			return ""		for a in range(len(col)):			if col[a]==retvalfields:				return results[0][a]#first record only		return ""	def getFields(self,db,cols):		#connectDBifRunAway()		curs=db.cursor()		if self._dbtype=="mysql":			sql="SHOW COLUMNS FROM " + cols			index=0		if self._dbtype=="sqllite":			sql="PRAGMA table_info("+cols+")"			index=1		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		ret=[]		for a in results:			ret.append(a[index])		return ret	#ExecuteNonQuerry(db,"INSERT INTO data (Name, Date, Time) VALUES ('%s', '%s', '%s')" % ("Bago", Date(),Time()) )	#ExecuteNonQuerry(db,"UPDATE data SET Name='%s' WHERE Name='%s'" % ("Wala","raks"))			#ExecuteNonQuerry(db,"DELETE FROM data WHERE Name='%s'" % ("Bago"))		def ExecuteNonQuerry(self,db,sql):		curs=db.cursor()		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			db.commit()		return ""		def ExecuteQuerry(self,db,sql):		curs=db.cursor()		for a in range(2):			try:				curs.execute (sql)				break			except OperationalError as e:				#do what you want to do on the error				self.reconnectMySql(db)			results = curs.fetchall()		return results	def getType(self,x):		long=int#PYTHON3		if type(x) is str:			return str		if type(x) is long:			return int		if x == None:			return str    		if type(x) is datetime.date:			return str #datetime.date		if type(x) is datetime.datetime:			return str# datetime.datetime    		if type(x) is datetime.timedelta:			return str #datetime.timedelta    		if type(x) is int:			return int		if type(x) is float:			return float				if type(x) is datetime.time:			return str #datetime.date        		if type(x) is datetime.timedelta:			return str #datetime.date    		return str #if not found	def getTable(self,sql,after="from"):		flag=False		x=sql.split(" ")		for a in x:			if flag==True:				if a.lower() in ["\r","\t","\n","\t"]:					continue				else:					return a			if a.lower()==after:				flag=True		###MySQL routineif __name__ == "__main__":	_m = Handler()	_m._window.show()	Gtk.main()