import giimport timegi.require_version('Gtk', '3.0')from gi.repository import Gtk,GObject,Gdk,Pango,GLibfrom wta_module import *import _adafruit_fingerprint as adafruit_fingerprinttry:	import serialexcept:	print ('serial not found, pip install pyserial!!!')	import sys 	sys.exit(-1)from _thread import *	#	Generated By WiredGTK for Python: by Rocky Nuarin, 2018 Phils#	#####################www.WireThemAll.com#####################class HardwareSerial:	def __init__(self,dev_tty,_parity=serial.PARITY_NONE,_stop=serial.STOPBITS_ONE,_bytesize=serial.EIGHTBITS,port=None):		self.dev_tty=dev_tty		self.ser=None		self.parity=_parity		self.stop=_stop		self.bytesize=_bytesize	def begin(self,_baud):		self.ser = serial.Serial(				port=self.dev_tty,				baudrate = _baud,				parity=self.parity,				stopbits=self.stop,				bytesize=self.bytesize,				timeout=5				)	def prints(self,_data):		if type(_data)!=bytes:			_data=str(_data).encode()		self.ser.write(_data)	def println(self,_data):		if type(_data)!=bytes:			_data=str(_data).encode()				self.ser.write(_data)		self.ser.write("\r\n".encode())	def write(self,_data):		#if type(_data)!=bytes:#for ada libs			#_data=str(_data).encode()				self.ser.write(_data)	def read(self,x):		return self.ser.read(x)		#w=self.ser.inWaiting()		#if w!=0:			#return self.ser.read(1)		#else:			#return ""	def available(self):		return self.ser.inWaiting()	def close(self):		return self.ser.close()	def Initialize(self):		if self.ser==None:			return False		else:			return Trueclass Handler(usercontrol):	#WiredEvent def CommEvent(self,e)	#add more events 	#WiredProperty 'Setting': '57600,n,8,1'	#WiredProperty 'Port':'COM1'	#WiredProperty 'Text': ''	#WiredEvent def VerifyFinish(self,id,confidence)	#add more events 	#WiredEvent def Notification(self,notif)	#add more events 	def __init__(self,*param):					initUI(self,param,w=400,h=400,title="WiredGTKV1.0",controlbox=True,startpos=(200,200),timeoutdestroy=-1)		self.GTKForms()		super().__init__(self.usercontrol)		self.sch=Scheduler(500)#500 ms		self.setting='9600,n,8,1'		self.Serial=HardwareSerial('')				self.sch.Start()		self._text=''		self._usercontrolproperty=''		self.FPVerifyframe1=bytearray([0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x03,0x01,0x00,0x05]);		self.FPVerifyframe2=[0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x04,0x02,0x01,0x00,0x08];		self.FPVerifyframe3=[0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x08,0x04,0x01,0x00,0x01,0x00,0x14,0x00,0x23];		self.InChar=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]						self.FPEnroll1=[0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x03,0x01,0x00,0x05];		self.FPEnroll2=[0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x04,0x02,0xCC,0x00, 0xCC];		self.FPEnroll3=[0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x03,0x05,0x00,0x09];		self.FPEnroll4=[0xEF,0x01,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x06,0x06,0x01,0x00,0xCC,0x00,0xCC];		self.verifyloop=False		@property	def Port(self):		return self.setting	@Port.setter			def Port(self,value):		self.port=value	@property	def Setting(self):		return self.setting	@Setting.setter	def Setting(self,value):		self.setting=value		self.baud=getCSV(0,',',value)		parity=getCSV(1,',',value)		self.bytesize=int(getCSV(2,',',value))		stop=getCSV(3,',',value)		if parity=='n':			self.parity=serial.PARITY_NONE		else:			self.parity=serial.PARITY_EVEN		if stop=='1':			self.stop=serial.STOPBITS_ONE		if stop=='2':			self.parity=serial.STOPBITS_TWO				pass		def Open(self):		self.Serial=HardwareSerial(self.port,self.parity,self.stop,self.bytesize)#Serial=HardwareSerial('/dev/ttyUSB0')		self.Serial.begin(self.baud)		self.finger=adafruit_fingerprint.Adafruit_Fingerprint(self.Serial)	def Close(self):		self.Serial.close()		pass		def get_fingerprintX(self):		"""Get a finger print image, template it, and see if it matches!"""		#print("Waiting for image...")		if 'Notification' in self.wiredevents:						self.wiredevents['Notification']("Waiting for image")				self.verifyloop=False		while(1):			if self.finger.get_image() == adafruit_fingerprint.OK:				break			if self.verifyloop==True:				self.verifyloop=False				self.finger=adafruit_fingerprint.Adafruit_Fingerprint(self.Serial)				return				#print("Templating...")		if 'Notification' in self.wiredevents:						self.wiredevents['Notification']("Templating")				ret=True		if self.finger.image_2_tz(1) != adafruit_fingerprint.OK:			ret=False		#print("Searching...")		if 'Notification' in self.wiredevents:						self.wiredevents['Notification']("Searching")				if self.finger.finger_fast_search() != adafruit_fingerprint.OK:			ret=False		if 'VerifyFinish' in self.wiredevents:						if ret==True:				self.wiredevents['VerifyFinish'](self.finger.finger_id,self.finger.confidence)												else:				self.wiredevents['VerifyFinish'](-1,-1)											self.verifyloop=False			def get_fingerprint(self):		self.verifyloop=True		delay(500)		start_new_thread(self.get_fingerprintX ,())				#pylint: disable=too-many-branches	def get_fingerprint_detail(self):		"""Get a finger print image, template it, and see if it matches!		This time, print out each error instead of just returning on failure"""		print("Getting image...", end="", flush=True)		i = self.finger.get_image()		if i == adafruit_fingerprint.OK:			print("Image taken")		else:			if i == adafruit_fingerprint.NOFINGER:				print("No finger detected")			elif i == adafruit_fingerprint.IMAGEFAIL:				print("Imaging error")			else:				print("Other error")			return False			print("Templating...", end="", flush=True)		i = self.finger.image_2_tz(1)		if i == adafruit_fingerprint.OK:			print("Templated")		else:			if i == adafruit_fingerprint.IMAGEMESS:				print("Image too messy")			elif i == adafruit_fingerprint.FEATUREFAIL:				print("Could not identify features")			elif i == adafruit_fingerprint.INVALIDIMAGE:				print("Image invalid")			else:				print("Other error")			return False			print("Searching...", end="", flush=True)		i = self.finger.finger_fast_search()		#pylint: disable=no-else-return		#This block needs to be refactored when it can be tested.		if i == adafruit_fingerprint.OK:			print("Found fingerprint!")			return True		else:			if i == adafruit_fingerprint.NOTFOUND:				print("No match found")			else:				print("Other error")			return False		#pylint: disable=too-many-statements	def enroll_finger(self,location):		self.verifyloop=True		delay(500)		start_new_thread(self.enroll_fingerX ,(location,))			def enroll_fingerX(self,location):		"""Take a 2 finger images and template it, then store in 'location'"""		self.verifyloop=False		for fingerimg in range(1, 3):			if fingerimg == 1:				#print("Place finger on sensor...", end="", flush=True)				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Place finger on sensor")			else:				#print("Place same finger again...", end="", flush=True)				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Place same finger again")				while True:				i = self.finger.get_image()				if self.verifyloop==True:					self.verifyloop=False					self.finger=adafruit_fingerprint.Adafruit_Fingerprint(self.Serial)					return				if i == adafruit_fingerprint.OK:					#print("Image taken")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Image taken")											break				elif i == adafruit_fingerprint.NOFINGER:					print(".", end="", flush=True)				elif i == adafruit_fingerprint.IMAGEFAIL:					#print("Imaging error")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Imaging error")											return False				else:					#print("Other error")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Other error")										return False				#print("Templating...", end="", flush=True)			if 'Notification' in self.wiredevents:							self.wiredevents['Notification']("Templating")						i = self.finger.image_2_tz(fingerimg)			if i == adafruit_fingerprint.OK:				#print("Templated")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Templated")							else:				if i == adafruit_fingerprint.IMAGEMESS:					#print("Image too messy")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Image too messy")											elif i == adafruit_fingerprint.FEATUREFAIL:					#print("Could not identify features")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Could not identify features")										elif i == adafruit_fingerprint.INVALIDIMAGE:					#print("Image invalid")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Image invalid")										else:					#print("Other error")					if 'Notification' in self.wiredevents:									self.wiredevents['Notification']("Other error")										return False				if fingerimg == 1:				#print("Remove finger")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Remove finger")														time.sleep(1)				while i != adafruit_fingerprint.NOFINGER:					i = self.finger.get_image()			#print("Creating model...", end="", flush=True)		if 'Notification' in self.wiredevents:						self.wiredevents['Notification']("Remove finger")				i = self.finger.create_model()		if i == adafruit_fingerprint.OK:			#print("Created")			if 'Notification' in self.wiredevents:							self.wiredevents['Notification']("Remove finger")					else:			if i == adafruit_fingerprint.ENROLLMISMATCH:				#print("Prints did not match")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Remove finger")							else:				#print("Other error")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Remove finger")							return False			#print("Storing model #%d..." % location, end="", flush=True)		if 'Notification' in self.wiredevents:						self.wiredevents['Notification']("Storing model #%d..." % location)				i = self.finger.store_model(location)		if i == adafruit_fingerprint.OK:			#print("Stored")			if 'Notification' in self.wiredevents:							self.wiredevents['Notification']("Stored")					else:			if i == adafruit_fingerprint.BADLOCATION:				#print("Bad storage location")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Bad storage location")							elif i == adafruit_fingerprint.FLASHERR:				#print("Flash storage error")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Flash storage error")							else:				#print("Other error")				if 'Notification' in self.wiredevents:								self.wiredevents['Notification']("Other error")							return False			return True			##################################################		def get_num(self):		"""Use input() to get a valid number from 1 to 127. Retry till success!"""		i = 0		while (i > 300) or (i < 1):			try:				i = int(input("Enter ID # from 1-127: "))			except ValueError:				pass		return i			def test(self):		print("----------------")		if self.finger.read_templates() != adafruit_fingerprint.OK:			raise RuntimeError('Failed to read templates')		print("Fingerprint templates:", self.finger.templates)		print("e) enroll print")		print("f) find print")		print("d) delete print")		print("----------------")		c = input("> ")			if c == 'e':			self.enroll_finger(self.get_num())		if c == 'f':			if self.get_fingerprint():				print("Detected #", self.finger.finger_id, "with confidence", self.finger.confidence)			else:				print("Finger not found")		if c == 'd':			if self.finger.delete_model(self.get_num()) == adafruit_fingerprint.OK:				print("Deleted!")			else:				print("Failed to delete")	@property		def usercontrolproperty(self):		return self._usercontrolproperty	@usercontrolproperty.setter		def usercontrolproperty(self,value):		self._usercontrolproperty=value	def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})	def activeXcreated(self,*args):				pass	def unload(self,*args):		destroy=True		if destroy==True:			GLib.source_remove(self.timeout_id)			self._window.hide()			del self._window			#ExitApplication() #activate this if u want to destroy this window			return False		else:			self.window.Visible=False			return True			def loop(self, user_data):		if self.form_load==False:			self.form_load=True		if self.verifyloop:			#if self.finger.get_image() == adafruit_fingerprint.OK:				#print("Templating...")				#if self.finger.image_2_tz(1) != adafruit_fingerprint.OK:					#if 'VerifyFinish' in self.wiredevents:						#self.wiredevents['VerifyFinish'](self.ctlFP_BEG2801.finger.finger_id,self.ctlFP_BEG2801.finger.confidence)									#print("Searching...")				#if self.finger.finger_fast_search() != adafruit_fingerprint.OK:					#if 'VerifyFinish' in self.wiredevents:						#self.wiredevents['VerifyFinish'](-1,-1)				#self.verifyloop=False				self.verifyloop=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 		def create(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		self.create("{'BackColor': '(1,1,1,1)', 'Text': 'Button1', 'Width': '100', 'Height': '50', 'Left': '130', 'Events': '[[, ]]', 'Top': '248', 'Font': '', 'Enable': 'True', 'Tag': '', 'Name': 'Button1', 'Picture': '', 'ParentsType': '', 'ForeColor': '(0,0,0,1)', 'Visible': 'True'}","Button","usercontrol","[]")	def Widget(self):		if self._usercontrol in self._mainlayout.get_children():			self._mainlayout.remove(self._usercontrol)		return self._usercontrol	def Hide(self):		self._window.hide()	def Show(self,modal=False,x=None,y=None):		if x!=None:			self._window.move(x,y)		self._window.set_modal(modal)		self._window.show()		Gtk.main()		return ""#put ur return value here upon closing this formif __name__ == "__main__":	_m = Handler()	_m._window.show()	Gtk.main()