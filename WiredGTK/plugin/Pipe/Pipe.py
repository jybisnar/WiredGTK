import giimport timegi.require_version('Gtk', '3.0')from gi.repository import Gtk,GObject,Gdk,Pango,GLibfrom wta_module import *#	Generated By WiredGTK for Python: by Rocky Nuarin, 2018 Phils#	#####################www.WireThemAll.com#####################import sysfrom subprocess import PIPE, Popenfrom threading  import Threadfrom queue import Queue, Emptyclass Handler(usercontrol):	#WiredEvent def finishExecuting(self)#	#WiredEvent def on_messagePipe(self,msg)	def __init__(self,*param):					initUI(self,param,w=400,h=400,title="WiredGTKV1.0",controlbox=True,startpos=(200,200),timeoutdestroy=-1)		self.GTKForms()		super().__init__(self.usercontrol)		self.sch=Scheduler(500)#500 ms		self.sch.Start()		self._text=''		self._usercontrolproperty=''		self.process=None		def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})	def activeXcreated(self,*args):		pass	def unload(self,*args):		destroy=True		if destroy==True:			GLib.source_remove(self.timeout_id)			self._window.hide()			del self._window			#ExitApplication() #activate this if u want to destroy this window			return False		else:			self.window.Visible=False			return True			def loop(self, user_data):		if self.process!=None:			self.CheckTraceError()		if self.process!=None and self.process.poll()!=None:			for a in range(3):				refreshGTK()				self.CheckTraceError()						self.btn_stop.Enable=False			self.run.Enable=True							self.process=None			print('Process terminated')			if self.caller!=None and 'finishExecuting' in self.wiredevents:self.wiredevents['finishExecuting']()		if self.form_load==False:			self.form_load=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 		def create(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		self.create("{'Picture': '', 'Tag': '', 'Enable': 'True', 'Help': '', 'BackColor': '(1,1,1,1)', 'Left': '150', 'ParentsType': '', 'Height': '50', 'Font': '', 'Width': '100', 'Visible': 'True', 'ForeColor': '(0,0,0,1)', 'Top': '180', 'Name': 'run', 'Events': '[clicked]', 'Var': '', 'Text': 'run'}","Button","usercontrol","[['clicked', 'self,e']]")		self.create("{'Picture': '', 'Tag': '', 'Enable': 'True', 'Help': '', 'BackColor': '(1,1,1,1)', 'Left': '260', 'ParentsType': '', 'Height': '50', 'Font': '', 'Width': '100', 'Visible': 'True', 'ForeColor': '(0,0,0,1)', 'Top': '180', 'Name': 'btn_stop', 'Events': '[clicked]', 'Var': '', 'Text': 'stop'}","Button","usercontrol","[['clicked', 'self,e']]")		self.create("{'Picture': '', 'Tag': '', 'Enable': 'True', 'Help': '', 'BackColor': '(0, 0.6708726728968983, 0.5331067846793819, 0.5)', 'Left': '360', 'ParentsType': '', 'Height': '300', 'Font': '', 'Width': '300', 'Visible': 'True', 'ForeColor': '(0,0,0,1)', 'Top': '90', 'Name': 'ScrolledWindow1', 'Events': '[[, ]]', 'Var': '', 'Text': 'ScrolledWindow1'}","ScrolledWindow","usercontrol","[]")		self.create("{'Picture': '', 'Tag': '', 'Enable': 'True', 'Help': '', 'BackColor': '(1,1,1,1)', 'Left': '150', 'ParentsType': '', 'Height': '50', 'Font': '', 'Width': '100', 'Visible': 'True', 'ForeColor': '(0,0,0,1)', 'Top': '245', 'Name': 'Button1', 'Events': '[clicked]', 'Var': '', 'Text': 'Button1'}","Button","usercontrol","[['clicked', 'self,e']]")		self.create("{'Picture': '', 'Tag': '', 'Enable': 'True', 'Help': '', 'BackColor': '(1,1,1,1)', 'Left': '20', 'ParentsType': 'ScrolledWindow', 'Height': '100', 'Font': '', 'Width': '170', 'Visible': 'True', 'ForeColor': '(0,0,0,1)', 'Top': '30', 'Name': 'Entry2', 'Events': '[[, ]]', 'Var': '', 'Text': 'TextView1'}","TextView","ScrolledWindow1","[]")	def Widget(self):		if self._usercontrol in self._mainlayout.get_children():			self._mainlayout.remove(self._usercontrol)		return self._usercontrol	def Hide(self):		self._window.hide()	def Show(self,modal=False,x=None,y=None):		if x!=None:			self._window.move(x,y)		if modal and self.caller!=None:			self._window.set_transient_for(self.caller._window)		self._window.set_modal(modal)		self._window.show()		Gtk.main()		return ""#put ur return value here upon closing this form	def CheckTraceError(self):		def getLine():			try:  line = self.queue.get_nowait()			except Empty:				return ""			else: # got line				#...do something with line				return line.decode()		def getLine2():			try:  line = self.queue2.get_nowait()			except Empty:				return ""			else: # got line				#...do something with line				return line.decode()				buf=getLine()		buf2=getLine2()		if (buf2!=''):			if self.caller!=None and 'on_messagePipe' in self.wiredevents:self.wiredevents['on_messagePipe'](buf2)			self.Entry2.Text+=buf2		line=''		while(buf!=''):			line+=buf			buf=getLine()		if line!='':			if self.caller!=None and 'on_messagePipe' in self.wiredevents:self.wiredevents['on_messagePipe']("stderr:" + line)			self.Entry2.Text+=line	def ExecCommand(self,cmdlst):		ON_POSIX = 'posix' in sys.builtin_module_names			def enqueue_output(out, queue):			for line in iter(out.readline, b''):				queue.put(line)			out.close()		def enqueue_output2(out, queue):			for line in iter(out.readline, b''):				queue.put(line)			out.close()#		python_name="python"		#		path='C:\\Users\\Acer\\Desktop\\untitled-1.py'#		self.process = Popen([python_name,'-u',path], stderr=PIPE,stdout=PIPE ,stdin=PIPE, bufsize=1, close_fds=ON_POSIX)		self.process = Popen(cmdlst, stderr=PIPE,stdout=PIPE ,stdin=PIPE, bufsize=1, close_fds=ON_POSIX)		self.queue = Queue()		self.queue2 = Queue()		t = Thread(target=enqueue_output, args=(self.process.stderr, self.queue))		t.daemon = True # thread dies with the program		t.start()							t = Thread(target=enqueue_output2, args=(self.process.stdout, self.queue2))		t.daemon = True # thread dies with the program		t.start()			self.run.Enable=False		self.btn_stop.Enable=True		pass	def btn_stop_clicked(self,e):		self.AbortExecution()		pass	def AbortExecution(self):		if self.process!=None:			self.process.terminate()		pass	def run_clicked(self,e):		#self.ExecCommand(["notepad.exe","raks.txt"])		self.ExecCommand(["python","-u",'C:\\Users\\Acer\\Desktop\\untitled-1.py'])		#self.ExecCommand(["cmd.exe"])		pass	def Button1_clicked(self,e):		#self.SendPipe("dir\n")#after running self.ExecCommand(["cmd.exe"])		pass	def SendPipe(self,cmd):		if self.process!=None:			self.process.stdin.write(cmd.encode())			self.process.stdin.flush()		passif __name__ == "__main__":	_m = Handler()	_m._window.show()	Gtk.main()